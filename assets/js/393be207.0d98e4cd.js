"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4134],{1943:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"type":"mdx","permalink":"/crypto-price-tracker/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don\'t need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}');var s=i(4848),t=i(8453);const a={title:"Markdown page example"},l="Markdown page example",c={},o=[{value:"sidebar_position: 1",id:"sidebar_position-1",level:2},{value:"Crypto Price Tracker",id:"crypto-price-tracker",level:2},{value:"Project Overview",id:"project-overview",level:3},{value:"Technology Stack",id:"technology-stack",level:3},{value:"Project Structure",id:"project-structure",level:3},{value:"sidebar_position: 2",id:"sidebar_position-2",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation",id:"installation",level:2},{value:"Project Structure",id:"project-structure-1",level:2},{value:"Environment Variables",id:"environment-variables",level:2},{value:"Building for Production",id:"building-for-production",level:2},{value:"sidebar_position: 3",id:"sidebar_position-3",level:2},{value:"CoinGecko API",id:"coingecko-api",level:2},{value:"How I Implemented the API Service",id:"how-i-implemented-the-api-service",level:2},{value:"Cryptocurrency Interface",id:"cryptocurrency-interface",level:3},{value:"Fetching Cryptocurrencies",id:"fetching-cryptocurrencies",level:3},{value:"Search Implementation",id:"search-implementation",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Rate Limiting Considerations",id:"rate-limiting-considerations",level:2},{value:"Challenge: Rate Limiting",id:"challenge-rate-limiting",level:3},{value:"Challenge: Current Rate Limiting Issues with Search",id:"challenge-current-rate-limiting-issues-with-search",level:3},{value:"UI Components",id:"ui-components",level:2},{value:"Table Layout",id:"table-layout",level:2},{value:"Sparkline Charts",id:"sparkline-charts",level:2},{value:"Currency Icons",id:"currency-icons",level:2},{value:"Responsive Design",id:"responsive-design",level:2},{value:"sidebar_position: 5",id:"sidebar_position-5",level:2},{value:"Development Journey",id:"development-journey",level:2},{value:"Challenge: Rate Limiting with Search Functionality",id:"challenge-rate-limiting-with-search-functionality",level:3},{value:"Challenge: Initial Design Approach",id:"challenge-initial-design-approach",level:3},{value:"Challenge: Future Enhancement Plans",id:"challenge-future-enhancement-plans",level:3},{value:"API Integration Challenges",id:"api-integration-challenges",level:2},{value:"Challenge: Rate Limiting",id:"challenge-rate-limiting-1",level:3},{value:"Challenge: Current Rate Limiting Issues with Search",id:"challenge-current-rate-limiting-issues-with-search-1",level:3},{value:"Challenge: Search Implementation",id:"challenge-search-implementation",level:3},{value:"State Management Challenges",id:"state-management-challenges",level:2},{value:"Challenge: Managing Search Results",id:"challenge-managing-search-results",level:3},{value:"Challenge: Refreshing Data",id:"challenge-refreshing-data",level:3},{value:"UI/UX Challenges",id:"uiux-challenges",level:2},{value:"Challenge: Loading States",id:"challenge-loading-states",level:3},{value:"Challenge: Responsive Design",id:"challenge-responsive-design",level:3},{value:"Error Handling Challenges",id:"error-handling-challenges",level:2},{value:"Challenge: Graceful Error Handling",id:"challenge-graceful-error-handling",level:3},{value:"Tips for Working with This Codebase",id:"tips-for-working-with-this-codebase",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"markdown-page-example",children:"Markdown page example"})}),"\n",(0,s.jsx)(n.p,{children:"You don't need React to write simple standalone pages."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sidebar_position-1",children:"sidebar_position: 1"}),"\n",(0,s.jsx)(n.h1,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.h2,{id:"crypto-price-tracker",children:"Crypto Price Tracker"}),"\n",(0,s.jsx)(n.p,{children:"The Crypto Price Tracker is a web application I built with Next.js that allows users to track live cryptocurrency prices. This documentation covers the project's setup, API integration, and the reasoning behind my technical decisions."}),"\n",(0,s.jsx)(n.h3,{id:"project-overview",children:"Project Overview"}),"\n",(0,s.jsx)(n.p,{children:"I created this tracker with several key features in mind:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Real-time display of popular cryptocurrency prices in a responsive table layout"}),"\n",(0,s.jsx)(n.li,{children:"Visual 7-day sparkline charts for each cryptocurrency"}),"\n",(0,s.jsx)(n.li,{children:"Price changes over multiple time periods (1h, 24h, 7d)"}),"\n",(0,s.jsx)(n.li,{children:"A search function to find specific cryptocurrencies"}),"\n",(0,s.jsx)(n.li,{children:"A manual refresh button for updating prices on demand"}),"\n",(0,s.jsx)(n.li,{children:"Responsive design that works well on any device"}),"\n",(0,s.jsx)(n.li,{children:"Loading indicators to improve the user experience"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"technology-stack",children:"Technology Stack"}),"\n",(0,s.jsx)(n.p,{children:"For this project, I selected these technologies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Next.js 15"})," - For server-side rendering and better performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"React 19"})," - The foundation for building the UI components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TypeScript"})," - To add type safety and improve code quality"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"React Query"})," - My choice for data fetching and state management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Axios"})," - For making HTTP requests to the CoinGecko API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Framer Motion"})," - To add subtle animations that enhance the UX"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tailwind CSS"})," - For rapid UI development with utility classes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.p,{children:"I organized the project with a modular structure to keep the code maintainable:\nsrc/\n\u251c\u2500\u2500 app/ # Next.js App Router\n\u2502 \u251c\u2500\u2500 page.tsx # Main dashboard page\n\u2502 \u251c\u2500\u2500 layout.tsx # Root layout\n\u2502 \u2514\u2500\u2500 globals.css # Global styles\n\u251c\u2500\u2500 components/ # Reusable UI components\n\u2502 \u251c\u2500\u2500 CryptoList.tsx # Table display of cryptocurrencies\n\u2502 \u251c\u2500\u2500 SparklineChart.tsx # 7-day price chart visualization\n\u2502 \u251c\u2500\u2500 SearchBar.tsx # Search functionality\n\u2502 \u251c\u2500\u2500 RefreshButton.tsx # Manual refresh button\n\u2502 \u2514\u2500\u2500 LoadingIndicator.tsx # Loading state indicator\n\u251c\u2500\u2500 services/ # API and data services\n\u2502 \u2514\u2500\u2500 cryptoService.ts # CoinGecko API integration\n\u2514\u2500\u2500 hooks/ # Custom React hooks\n\u2514\u2500\u2500 useCryptoData.ts # React Query hook for crypto data"}),"\n",(0,s.jsx)(n.p,{children:"This structure helps separate concerns and makes it easier to navigate the codebase."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sidebar_position-2",children:"sidebar_position: 2"}),"\n",(0,s.jsx)(n.h1,{id:"setup-guide",children:"Setup Guide"}),"\n",(0,s.jsx)(n.p,{children:"This guide will walk you through setting up and running the Crypto Price Tracker project on your local machine."}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"Before diving in, make sure you have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Node.js 18.x or later (I developed this with Node 18.16.0)"}),"\n",(0,s.jsx)(n.li,{children:"npm or yarn package manager"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.p,{children:"Follow these steps to get up and running:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Clone the repository:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/yourusername/crypto-price-tracker.git\ncd crypto-price-tracker\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Install dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install\n# or\nyarn install\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Fire up the development server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run dev\n# or\nyarn dev\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Open ",(0,s.jsx)(n.a,{href:"http://localhost:3000",children:"http://localhost:3000"})," in your browser and you should see the app running!"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"project-structure-1",children:"Project Structure"}),"\n",(0,s.jsx)(n.p,{children:"I've organized the code into these main directories:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/app"}),": Contains the Next.js App Router files - the backbone of the application"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/components"}),": Houses all the UI components - I've kept these modular and reusable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/services"}),": Contains the API service functions - all external data fetching happens here"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/hooks"}),": Custom React hooks that handle state and data flow"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,s.jsxs)(n.p,{children:["The project uses the CoinGecko public API which doesn't require an API key for basic usage. If you need to configure environment variables (for example, if you want to use a different API), create a ",(0,s.jsx)(n.code,{children:".env.local"})," file in the root directory:"]}),"\n",(0,s.jsxs)(n.p,{children:["NEXT_PUBLIC_API_URL=",(0,s.jsx)(n.a,{href:"https://api.coingecko.com/api/v3",children:"https://api.coingecko.com/api/v3"})]}),"\n",(0,s.jsx)(n.p,{children:"I've kept external dependencies minimal to make setup easier."}),"\n",(0,s.jsx)(n.h2,{id:"building-for-production",children:"Building for Production"}),"\n",(0,s.jsx)(n.p,{children:"When you're ready to deploy, build the application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run build\n# or\nyarn build\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then start the production server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run start\n# or\nyarn start\n"})}),"\n",(0,s.jsx)(n.p,{children:"The production build is optimized for performance and should run significantly faster than the development version."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sidebar_position-3",children:"sidebar_position: 3"}),"\n",(0,s.jsx)(n.h1,{id:"api-integration",children:"API Integration"}),"\n",(0,s.jsx)(n.h2,{id:"coingecko-api",children:"CoinGecko API"}),"\n",(0,s.jsxs)(n.p,{children:["For this project, I chose the ",(0,s.jsx)(n.a,{href:"https://www.coingecko.com/en/api",children:"CoinGecko API"})," because I've used it before while being reliable,, and offering free access to cryptocurrency data. It provides all the information we need without requiring authentication for basic usage which is a huge bonus."]}),"\n",(0,s.jsx)(n.h2,{id:"how-i-implemented-the-api-service",children:"How I Implemented the API Service"}),"\n",(0,s.jsxs)(n.p,{children:["I created a dedicated service in ",(0,s.jsx)(n.code,{children:"src/services/cryptoService.ts"})," to handle all API interactions. This keeps the API logic separate from the UI components and makes the code more maintainable."]}),"\n",(0,s.jsx)(n.h3,{id:"cryptocurrency-interface",children:"Cryptocurrency Interface"}),"\n",(0,s.jsx)(n.p,{children:"First, I defined a TypeScript interface to represent the cryptocurrency data structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface Cryptocurrency {\n  id: string;\n  symbol: string;\n  name: string;\n  image: string;\n  current_price: number;\n  market_cap: number;\n  price_change_percentage_24h: number;\n  price_change_percentage_1h_in_currency?: number;\n  price_change_percentage_7d_in_currency?: number;\n  sparkline_in_7d?: {\n    price: number[];\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This gives us type safety throughout the application and makes it clear what data we're working with."}),"\n",(0,s.jsx)(n.h3,{id:"fetching-cryptocurrencies",children:"Fetching Cryptocurrencies"}),"\n",(0,s.jsx)(n.p,{children:"The main function to fetch cryptocurrency data looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const fetchCryptocurrencies = async (limit = 5): Promise<Cryptocurrency[]> => {\n  try {\n    const response = await axios.get(`${API_URL}/coins/markets`, {\n      params: {\n        vs_currency: 'usd',\n        order: 'market_cap_desc',\n        per_page: limit,\n        page: 1,\n        sparkline: true,\n        price_change_percentage: '1h,24h,7d'\n      },\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching cryptocurrencies:', error);\n    throw error;\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"I set the default limit to 5 cryptocurrencies to keep the initial load fast, but this can be adjusted as needed."}),"\n",(0,s.jsx)(n.h3,{id:"search-implementation",children:"Search Implementation"}),"\n",(0,s.jsx)(n.p,{children:"The search functionality was tricky to implement. CoinGecko's search endpoint doesn't return price data directly, so I had to create a two-step process:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const searchCryptocurrencies = async (query: string): Promise<Cryptocurrency[]> => {\n  try {\n    // Step 1: Search for cryptocurrencies by name/symbol\n    const response = await axios.get(`${API_URL}/search`, {\n      params: {\n        query,\n      },\n    });\n    \n    // Step 2: Get detailed information for the search results\n    const coins = response.data.coins.slice(0, 5);\n    if (coins.length === 0) return [];\n    \n    const ids = coins.map((coin: any) => coin.id).join(',');\n    \n    const detailedResponse = await axios.get(`${API_URL}/coins/markets`, {\n      params: {\n        vs_currency: 'usd',\n        ids,\n        order: 'market_cap_desc',\n        sparkline: false,\n      },\n    });\n    \n    return detailedResponse.data;\n  } catch (error) {\n    console.error('Error searching cryptocurrencies:', error);\n    throw error;\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This approach gives us the best of both worlds: the search capability of the ",(0,s.jsx)(n.code,{children:"/search"})," endpoint and the detailed price data from the ",(0,s.jsx)(n.code,{children:"/coins/markets"})," endpoint."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"I've built robust error handling into the API service to catch issues before they affect the user experience. When something goes wrong with an API call, we log it and show a friendly message to the user."}),"\n",(0,s.jsx)(n.p,{children:"All API calls are wrapped in try/catch blocks, and errors are propagated up to the UI layer where they can be handled appropriately."}),"\n",(0,s.jsx)(n.h2,{id:"rate-limiting-considerations",children:"Rate Limiting Considerations"}),"\n",(0,s.jsx)(n.p,{children:"CoinGecko's free API has rate limits (about 10-50 calls per minute depending on the endpoint). To respect these limits and provide a good user experience, I:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implemented caching with React Query to reduce redundant API calls"}),"\n",(0,s.jsx)(n.li,{children:"Added a manual refresh button instead of automatic polling"}),"\n",(0,s.jsx)(n.li,{children:"Limited the number of cryptocurrencies fetched at once"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These measures help prevent hitting rate limits while still providing up-to-date information."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-rate-limiting",children:"Challenge: Rate Limiting"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": The CoinGecko API has rate limits that could be easily exceeded during development and testing."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nWhen I first started making API calls, I quickly ran into rate limiting issues during testing. To solve this, I:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implemented caching with React Query to reduce the number of API calls"}),"\n",(0,s.jsx)(n.li,{children:"Added a manual refresh button instead of automatic polling"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate stale times for queries to prevent unnecessary refetching"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These changes dramatically reduced the number of API calls and prevented rate limit errors."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-current-rate-limiting-issues-with-search",children:"Challenge: Current Rate Limiting Issues with Search"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": The search functionality makes two API calls in quick succession (one to ",(0,s.jsx)(n.code,{children:"/search"})," and another to ",(0,s.jsx)(n.code,{children:"/coins/markets"}),"), which can easily trigger rate limits, especially when users type quickly or make multiple searches."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Current Implementation Limitations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only uses a 1-second delay between retries"}),"\n",(0,s.jsx)(n.li,{children:"Makes two API calls for each search query"}),"\n",(0,s.jsx)(n.li,{children:"Simple retry mechanism may not be sufficient for heavy usage"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Potential Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement request debouncing for search input"}),"\n",(0,s.jsx)(n.li,{children:"Increase the retry delay to 30-60 seconds when rate limited"}),"\n",(0,s.jsx)(n.li,{children:"Cache search results for frequently searched terms"}),"\n",(0,s.jsx)(n.li,{children:"Add a proper rate limiter that tracks API calls across the entire application"}),"\n",(0,s.jsx)(n.li,{children:"Consider implementing server-side caching for popular searches"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ui-components",children:"UI Components"}),"\n",(0,s.jsx)(n.h2,{id:"table-layout",children:"Table Layout"}),"\n",(0,s.jsx)(n.p,{children:"I implemented a responsive table layout to display cryptocurrency data in an organized and scannable format. The table includes columns for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rank (#)"}),"\n",(0,s.jsx)(n.li,{children:"Coin name and symbol with icon"}),"\n",(0,s.jsx)(n.li,{children:"Current price"}),"\n",(0,s.jsx)(n.li,{children:"Price changes (1h, 24h, 7d)"}),"\n",(0,s.jsx)(n.li,{children:"7-day sparkline chart"}),"\n",(0,s.jsx)(n.li,{children:"Market cap"}),"\n",(0,s.jsx)(n.li,{children:"Action button"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The table is fully responsive and adapts to different screen sizes, with the sparkline column hiding on mobile devices to preserve space."}),"\n",(0,s.jsx)(n.h2,{id:"sparkline-charts",children:"Sparkline Charts"}),"\n",(0,s.jsx)(n.p,{children:"One of the key visual features is the 7-day sparkline chart for each cryptocurrency. I implemented this using HTML Canvas for optimal performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const SparklineChart: React.FC<SparklineChartProps> = ({\n    data,\n    width = 120,\n    height = 40,\n    lineColor,\n    lineWidth = 1.5,\n}) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const isPositive = data.length > 1 ? data[data.length - 1] > data[0] : true;\n    const defaultColor = isPositive ? '#10B981' : '#EF4444'; // green for positive, red for negative\n    const color = lineColor || defaultColor;\n\n    useEffect(() => {\n        if (!canvasRef.current || !data || data.length === 0) return;\n\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n\n        // Draw the sparkline\n        // ... drawing logic ...\n    }, [data, width, height, color, lineWidth]);\n\n    return (\n        <canvas\n            ref={canvasRef}\n            width={width}\n            height={height}\n            className=\"inline-block\"\n        />\n    );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"The sparklines are color-coded (green for positive trends, red for negative) and provide a quick visual representation of price movement over the past week."}),"\n",(0,s.jsx)(n.h2,{id:"currency-icons",children:"Currency Icons"}),"\n",(0,s.jsx)(n.p,{children:"I enhanced the currency icons with a circular border and background for a more polished look:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'<div className="w-10 h-10 flex-shrink-0 mr-3 bg-gray-100 rounded-full p-1 border border-gray-200">\n    <img src={crypto.image} alt={crypto.name} className="w-full h-full rounded-full" />\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"This gives the icons a more polished and consistent appearance throughout the application."}),"\n",(0,s.jsx)(n.h2,{id:"responsive-design",children:"Responsive Design"}),"\n",(0,s.jsx)(n.p,{children:"I implemented a fully responsive design that works well on devices of all sizes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"On desktop, the full table is displayed with all columns"}),"\n",(0,s.jsx)(n.li,{children:"On tablets, the layout adjusts with optimized spacing"}),"\n",(0,s.jsx)(n.li,{children:"On mobile devices, the sparkline column is hidden and text sizes are reduced"}),"\n",(0,s.jsx)(n.li,{children:"The table becomes horizontally scrollable on very small screens"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures a good user experience regardless of the device being used."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"sidebar_position-5",children:"sidebar_position: 5"}),"\n",(0,s.jsx)(n.h1,{id:"challenges--solutions",children:"Challenges & Solutions"}),"\n",(0,s.jsx)(n.h2,{id:"development-journey",children:"Development Journey"}),"\n",(0,s.jsx)(n.p,{children:"I started this project by setting up the basic Next.js structure and planning the component hierarchy. The first challenge was deciding on a state management approach - I considered several options including Context API and Zustand, but ultimately chose React Query because of its built-in caching and data fetching capabilities."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-rate-limiting-with-search-functionality",children:"Challenge: Rate Limiting with Search Functionality"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Our search functionality is currently experiencing rate limiting issues because it makes two API calls in quick succession (one to ",(0,s.jsx)(n.code,{children:"/search"})," and another to ",(0,s.jsx)(n.code,{children:"/coins/markets"}),"). This is particularly problematic when users type quickly or make multiple searches."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Current Implementation Limitations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The retry mechanism only uses a 1-second delay between retries"}),"\n",(0,s.jsx)(n.li,{children:"Each search requires two separate API calls"}),"\n",(0,s.jsx)(n.li,{children:"The simple retry mechanism isn't sufficient for heavy usage patterns"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution In Progress"}),":\nWe're currently working on improving this by considering several approaches:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implementing request debouncing for search input to prevent rapid-fire API calls"}),"\n",(0,s.jsx)(n.li,{children:"Increasing the retry delay to 30-60 seconds when rate limited"}),"\n",(0,s.jsx)(n.li,{children:"Adding a caching layer for frequently searched terms"}),"\n",(0,s.jsx)(n.li,{children:"Implementing a proper rate limiter to track API calls across the application"}),"\n",(0,s.jsx)(n.li,{children:"Adding server-side caching for popular searches"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These improvements will help manage the API rate limits more effectively while maintaining a smooth user experience."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-initial-design-approach",children:"Challenge: Initial Design Approach"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": When I first started the project, I struggled with creating a cohesive and professional design that would effectively display complex cryptocurrency data while maintaining good user experience."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nMy breakthrough came when I started thinking about the user journey and breaking down the UI into smaller, manageable components. I began with a basic table layout and iteratively improved it:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"First, I focused on the core functionality and basic layout"}),"\n",(0,s.jsx)(n.li,{children:"Then, I added visual hierarchy using typography and spacing"}),"\n",(0,s.jsx)(n.li,{children:"Finally, I incorporated interactive elements like hover states and animations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The turning point came when I started using Tailwind CSS's utility classes systematically. What initially felt overwhelming became intuitive as I developed a consistent pattern for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Using spacing utilities (margin and padding)"}),"\n",(0,s.jsx)(n.li,{children:"Implementing responsive designs"}),"\n",(0,s.jsx)(n.li,{children:"Creating consistent color schemes"}),"\n",(0,s.jsx)(n.li,{children:"Adding interactive states"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'This systematic approach helped everything "click" into place, and the design started feeling more cohesive and professional.'}),"\n",(0,s.jsx)(n.h3,{id:"challenge-future-enhancement-plans",children:"Challenge: Future Enhancement Plans"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": While developing this project, I identified several features I wanted to implement but had to prioritize core functionality first."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Current Status"}),": I've created a roadmap of future enhancements that I plan to learn and implement:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dark/Light Mode Toggle"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Learning how to implement theme switching in Next.js"}),"\n",(0,s.jsx)(n.li,{children:"Understanding CSS variables for theming"}),"\n",(0,s.jsx)(n.li,{children:"Implementing user preference persistence"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advanced Chart Visualizations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implementing interactive price history charts"}),"\n",(0,s.jsx)(n.li,{children:"Adding date range selectors"}),"\n",(0,s.jsx)(n.li,{children:"Creating comparison views for multiple cryptocurrencies"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Example of theme implementation (future enhancement)\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <ThemeProvider attribute="class" defaultTheme="system">\n      <Component {...pageProps} />\n    </ThemeProvider>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"These enhancements represent my learning roadmap as I continue to develop my skills in React and Next.js development."}),"\n",(0,s.jsx)(n.h2,{id:"api-integration-challenges",children:"API Integration Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"challenge-rate-limiting-1",children:"Challenge: Rate Limiting"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": The CoinGecko API has rate limits that could be easily exceeded during development and testing."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nWhen I first started making API calls, I quickly ran into rate limiting issues during testing. To solve this, I:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implemented caching with React Query to reduce the number of API calls"}),"\n",(0,s.jsx)(n.li,{children:"Added a manual refresh button instead of automatic polling"}),"\n",(0,s.jsx)(n.li,{children:"Set appropriate stale times for queries to prevent unnecessary refetching"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These changes dramatically reduced the number of API calls and prevented rate limit errors."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-current-rate-limiting-issues-with-search-1",children:"Challenge: Current Rate Limiting Issues with Search"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": The search functionality makes two API calls in quick succession (one to ",(0,s.jsx)(n.code,{children:"/search"})," and another to ",(0,s.jsx)(n.code,{children:"/coins/markets"}),"), which can easily trigger rate limits, especially when users type quickly or make multiple searches."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Current Implementation Limitations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Only uses a 1-second delay between retries"}),"\n",(0,s.jsx)(n.li,{children:"Makes two API calls for each search query"}),"\n",(0,s.jsx)(n.li,{children:"Simple retry mechanism may not be sufficient for heavy usage"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Potential Solutions"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Implement request debouncing for search input"}),"\n",(0,s.jsx)(n.li,{children:"Increase the retry delay to 30-60 seconds when rate limited"}),"\n",(0,s.jsx)(n.li,{children:"Cache search results for frequently searched terms"}),"\n",(0,s.jsx)(n.li,{children:"Add a proper rate limiter that tracks API calls across the entire application"}),"\n",(0,s.jsx)(n.li,{children:"Consider implementing server-side caching for popular searches"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"challenge-search-implementation",children:"Challenge: Search Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": The CoinGecko search API returns limited data that doesn't include price information."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nWhen I first implemented the search functionality, I hit a roadblock with the CoinGecko API. The search endpoint didn't return price data, which was frustrating. After digging through their documentation, I realized I needed to implement a two-step process:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["First, search for cryptocurrencies by name/symbol using the ",(0,s.jsx)(n.code,{children:"/search"})," endpoint"]}),"\n",(0,s.jsxs)(n.li,{children:["Then, fetch detailed information for the search results using the ",(0,s.jsx)(n.code,{children:"/coins/markets"})," endpoint with the IDs from the search results"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export const searchCryptocurrencies = async (query: string): Promise<Cryptocurrency[]> => {\n  try {\n    // Step 1: Search for cryptocurrencies\n    const response = await axios.get(`${API_URL}/search`, {\n      params: { query },\n    });\n    \n    // Step 2: Get detailed information for the search results\n    const coins = response.data.coins.slice(0, 5);\n    if (coins.length === 0) return [];\n    \n    const ids = coins.map((coin: any) => coin.id).join(',');\n    \n    const detailedResponse = await axios.get(`${API_URL}/coins/markets`, {\n      params: {\n        vs_currency: 'usd',\n        ids,\n        order: 'market_cap_desc',\n        sparkline: false,\n      },\n    });\n    \n    return detailedResponse.data;\n  } catch (error) {\n    console.error('Error searching cryptocurrencies:', error);\n    throw error;\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach worked well, though it does mean each search requires two API calls."}),"\n",(0,s.jsx)(n.h2,{id:"state-management-challenges",children:"State Management Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"challenge-managing-search-results",children:"Challenge: Managing Search Results"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": I needed to maintain both the default list of cryptocurrencies and search results without conflicts."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nI initially tried to store both sets of data in React Query, but this led to confusion when switching between views. Instead, I:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Used React Query for the default list of cryptocurrencies"}),"\n",(0,s.jsx)(n.li,{children:"Used local React state for search results"}),"\n",(0,s.jsx)(n.li,{children:"Created a display mode state to toggle between default and search views"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const [displayMode, setDisplayMode] = useState<'default' | 'search'>('default');\nconst [searchResults, setSearchResults] = useState<Cryptocurrency[]>([]);\n\n// In the search mutation\nconst searchCrypto = useMutation({\n  mutationFn: (query: string) => searchCryptocurrencies(query),\n  onSuccess: (data) => {\n    setSearchResults(data);\n    setDisplayMode('search');\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This separation made the code much cleaner and easier to reason about."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-refreshing-data",children:"Challenge: Refreshing Data"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": I needed a way to manually refresh data while showing loading state."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nI tried a few approaches here, including using the ",(0,s.jsx)(n.code,{children:"refetch"})," function from ",(0,s.jsx)(n.code,{children:"useQuery"}),", but I wanted more control over the process. I ended up using React Query's ",(0,s.jsx)(n.code,{children:"useMutation"})," for the refresh functionality:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const refreshData = useMutation({\n  mutationFn: () => fetchCryptocurrencies(limit),\n  onSuccess: (newData) => {\n    queryClient.setQueryData(['cryptocurrencies', limit], newData);\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach gave me fine-grained control over the loading state and allowed me to update the cache directly."}),"\n",(0,s.jsx)(n.h2,{id:"uiux-challenges",children:"UI/UX Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"challenge-loading-states",children:"Challenge: Loading States"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": I needed to show loading states during API calls without full page reloads."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nI created a reusable ",(0,s.jsx)(n.code,{children:"LoadingIndicator"})," component with Framer Motion animations. The trickiest part was deciding when to show loading states - I didn't want to show a loading spinner for quick refreshes, but I needed to indicate that something was happening."]}),"\n",(0,s.jsxs)(n.p,{children:["I ended up using React Query's ",(0,s.jsx)(n.code,{children:"isLoading"})," and ",(0,s.jsx)(n.code,{children:"isPending"})," states to control when to show loading indicators:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'{isLoading ? (\n  <LoadingIndicator size="large" />\n) : (\n  <CryptoList cryptocurrencies={displayedCryptos} />\n)}\n'})}),"\n",(0,s.jsx)(n.p,{children:"For the refresh button, I added a smaller loading indicator inside the button itself, which provides feedback without disrupting the UI."}),"\n",(0,s.jsx)(n.h3,{id:"challenge-responsive-design",children:"Challenge: Responsive Design"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Ensuring the application works well on all device sizes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nI started with a mobile-first approach and used Tailwind CSS's responsive utilities to adapt the layout for larger screens. The grid layout for cryptocurrency cards was particularly challenging to get right:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">\n  {cryptocurrencies.map((crypto) => (\n    <CryptoCard key={crypto.id} crypto={crypto} />\n  ))}\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"This creates a single column on mobile, two columns on medium screens, and three columns on large screens. I tested extensively on different devices to ensure everything looked good."}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-challenges",children:"Error Handling Challenges"}),"\n",(0,s.jsx)(n.h3,{id:"challenge-graceful-error-handling",children:"Challenge: Graceful Error Handling"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": I needed to handle API errors gracefully without breaking the UI."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":\nMy first attempt at error handling was too basic - just a console.log in the catch block. This wasn't helpful for users. I improved it by:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implementing try/catch blocks in all API calls"}),"\n",(0,s.jsx)(n.li,{children:"Creating error states in the UI to display user-friendly error messages"}),"\n",(0,s.jsx)(n.li,{children:"Using React Query's built-in error handling"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'if (error) {\n  return (\n    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">\n      <strong className="font-bold">Error!</strong>\n      <span className="block sm:inline"> Failed to load cryptocurrency data. Please try again later.</span>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This approach ensures users always know what's happening, even when things go wrong."}),"\n",(0,s.jsx)(n.h2,{id:"tips-for-working-with-this-codebase",children:"Tips for Working with This Codebase"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When adding new API endpoints, follow the pattern in cryptoService.ts"}),"\n",(0,s.jsx)(n.li,{children:"The React Query hooks are centralized in the hooks directory for easier maintenance"}),"\n",(0,s.jsx)(n.li,{children:"Component props are strictly typed with TypeScript interfaces for better code completion"}),"\n",(0,s.jsx)(n.li,{children:"If you need to modify the UI, the component structure follows atomic design principles"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Building this Crypto Price Tracker taught me a lot about working with external APIs and managing state in React applications. The combination of React Query for state management, careful API integration, and responsive UI design resulted in a smooth user experience despite the inherent challenges of working with external APIs and real-time data."}),"\n",(0,s.jsx)(n.p,{children:"If I were to continue developing this application, I'd add features like price history charts, cryptocurrency comparisons, and portfolio tracking functionality."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(6540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);